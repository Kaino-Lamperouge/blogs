(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{314:function(v,_,o){"use strict";o.r(_);var e=o(14),s=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"hook"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hook"}},[v._v("#")]),v._v(" Hook")]),v._v(" "),_("p",[_("code",[v._v("Hook")]),v._v(" 是一种在计算机编程中常见的术语，它指的是一种用于扩展和定制应用程序或框架功能的机制。通过使用 "),_("code",[v._v("Hook")]),v._v(" ，开发人员可以在不修改原始代码的情况下，添加或修改应用程序或框架的行为。")]),v._v(" "),_("p",[v._v("在前端开发中， "),_("code",[v._v("Hook")]),v._v(" 通常被用于 "),_("code",[v._v("React")]),v._v(" 、 "),_("code",[v._v("Vue")]),v._v(" 等框架中，用于在组件之间共享状态、处理副作用、添加额外的逻辑等。在 "),_("code",[v._v("React")]),v._v(" 中， "),_("code",[v._v("Hook")]),v._v(" 是一种函数组件可以使用的状态管理机制，它使得组件可以更方便地访问和修改状态。")]),v._v(" "),_("p",[_("code",[v._v("Hook")]),v._v(" 通常具有以下特点：")]),v._v(" "),_("ol",[_("li",[v._v("钩子函数是一个纯函数，没有副作用。")]),v._v(" "),_("li",[v._v("钩子函数可以在组件的任何地方调用，但应该在组件挂载前调用。")]),v._v(" "),_("li",[v._v("钩子函数可以在组件之间共享状态，但应该避免在组件内部使用。")]),v._v(" "),_("li",[v._v("钩子函数可以用于处理副作用，但应该避免在渲染过程中使用。")])]),v._v(" "),_("p",[v._v("总之， "),_("code",[v._v("Hook")]),v._v(" 是一种非常有用的机制，可以用于扩展和定制应用程序或框架的功能，提高代码的可维护性和可重用性。")]),v._v(" "),_("h2",{attrs:{id:"hooks-的优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hooks-的优点"}},[v._v("#")]),v._v(" "),_("code",[v._v("hooks")]),v._v(" 的优点")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("hooks")]),v._v(" 作为独立逻辑的组件封装，其内部的属性、函数等和外部组件具有响应式依附的作用。")]),v._v(" "),_("li",[v._v("自定义 "),_("code",[v._v("hook")]),v._v(" 的作用类似于 "),_("code",[v._v("vue2")]),v._v(" 中的 "),_("code",[v._v("mixin")]),v._v(" 技术，使用方便，易于上手。")]),v._v(" "),_("li",[v._v("使用 "),_("code",[v._v("Vue3")]),v._v(" 的组合 "),_("code",[v._v("API")]),v._v(" 封装的可复用，高内聚低耦合。")])]),v._v(" "),_("h2",{attrs:{id:"自定义-hook-规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自定义-hook-规范"}},[v._v("#")]),v._v(" 自定义 hook 规范")]),v._v(" "),_("ol",[_("li",[v._v("具备可复用功能，才需要抽离为 "),_("code",[v._v("hooks")]),v._v(" 独立文件")]),v._v(" "),_("li",[v._v("函数名/文件名以 "),_("code",[v._v("use")]),v._v(" 开头，形如: "),_("code",[v._v("useXX")])]),v._v(" "),_("li",[v._v("引用时将响应式变量或者方法显式解构暴露出来；")])]),v._v(" "),_("div",{staticClass:"language-js extra-class"},[_("pre",{pre:!0,attrs:{class:"language-js"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("const")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v(" nameRef"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" Fn "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("useXX")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])])]),_("h2",{attrs:{id:"hooks-和-utils-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hooks-和-utils-区别"}},[v._v("#")]),v._v(" "),_("code",[v._v("hooks")]),v._v(" 和 "),_("code",[v._v("utils")]),v._v(" 区别")]),v._v(" "),_("p",[v._v("相同点：")]),v._v(" "),_("p",[v._v("通过 "),_("code",[v._v("hooks")]),v._v(" 和 "),_("code",[v._v("utils")]),v._v(" 函数封装， 可以实现组件间共享和复用，提高代码的可重用性和可维护性。")]),v._v(" "),_("p",[v._v("异同点：")]),v._v(" "),_("ol",[_("li",[v._v("表现形式不同\n"),_("code",[v._v("hooks")]),v._v(" 是在 "),_("code",[v._v("utils")]),v._v(" 的基础上再包一层组件级别的东西(钩子函数等)； "),_("code",[v._v("utils")]),v._v(" 一般用于封装相应的逻辑函数，没有组件的东西；")]),v._v(" "),_("li",[v._v("数据是否具有响应式\n"),_("code",[v._v("hooks")]),v._v(" 中如果涉及到 "),_("code",[v._v("ref")]),v._v(" ， "),_("code",[v._v("reactive")]),v._v(" ， "),_("code",[v._v("computed")]),v._v(" 这些 "),_("code",[v._v("api")]),v._v(" 的数据，是具有响应式的；而 "),_("code",[v._v("utils")]),v._v(" 只是单纯提取公共方法就不具备响应式；")]),v._v(" "),_("li",[v._v("作用范围不同\n"),_("code",[v._v("hooks")]),v._v(" 封装，可以将组件的状态和生命周期方法提取出来，并在多个组件之间共享和重用； "),_("code",[v._v("utils")]),v._v(" 通常是指一些辅助函数或工具方法，用于实现一些常见的操作或提供特定功能。")])]),v._v(" "),_("p",[_("code",[v._v("utils")]),v._v(" 是通用的工具函数，而 "),_("code",[v._v("hooks")]),v._v(" 是对 "),_("code",[v._v("utils")]),v._v(" 的一种封装，用于在组件中共享状态逻辑和副作用。")]),v._v(" "),_("p",[v._v("通过使用 "),_("code",[v._v("hooks")]),v._v(" ，可以简化代码，并使其更具可读性和可维护性。")]),v._v(" "),_("h2",{attrs:{id:"hooks-和-mixin-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hooks-和-mixin-区别"}},[v._v("#")]),v._v(" hooks 和 mixin 区别")]),v._v(" "),_("p",[_("code",[v._v("hooks")]),v._v(" 和 "),_("code",[v._v("mixin")]),v._v(" ，都是常用代码逻辑抽离手段，方便进行代码复用；")]),v._v(" "),_("p",[v._v("异同点：")]),v._v(" "),_("ol",[_("li",[v._v("语法和用法不同\n"),_("code",[v._v("Hooks")]),v._v(" 是在 "),_("code",[v._v("Vue3")]),v._v(" 的 "),_("code",[v._v("Composition API")]),v._v(" 中引入的一种函数式编程的方式，而 "),_("code",[v._v("Mixins")]),v._v(" 是在 "),_("code",[v._v("Vue2")]),v._v(" 中的一种对象混入机制。"),_("code",[v._v("Hooks")]),v._v(" 使用函数的方式定义和使用，而 "),_("code",[v._v("Mixins")]),v._v(" 则是通过对象的方式进行定义和应用。")]),v._v(" "),_("li",[v._v("组合性和灵活性不同\n"),_("code",[v._v("Hooks")]),v._v(" 允许开发者根据逻辑功能来组合代码，封装为自定义 "),_("code",[v._v("Hook")]),v._v(" 函数，提高代码复用率。而 "),_("code",[v._v("Mixins")]),v._v(" 在组件中的属性和方法会与组件本身的属性和方法进行合并，可能会导致命名冲突或不可预料的行为。")]),v._v(" "),_("li",[v._v("响应式系统不同\n"),_("code",[v._v("Vue3")]),v._v(" 的 "),_("code",[v._v("Composition API")]),v._v(" 使用了一个新的响应式系统，可以通过 "),_("code",[v._v("reactive")]),v._v(" 和 "),_("code",[v._v("ref")]),v._v(" 来创建响应式数据，可以更精确地控制组件的更新和依赖追踪。而 "),_("code",[v._v("Mixins")]),v._v(" 使用 "),_("code",[v._v("Vue2")]),v._v(" 的响应式系统，对数据的追踪和更新较为简单，可能存在一些性能上的问题。")]),v._v(" "),_("li",[v._v("生命周期钩子不同\n在 "),_("code",[v._v("Vue3")]),v._v(" 的 "),_("code",[v._v("Composition API")]),v._v(" 中，可以使用 "),_("code",[v._v("onMounted")]),v._v("、"),_("code",[v._v("onUpdated")]),v._v(" 等钩子函数来替代 "),_("code",[v._v("Vue2")]),v._v(" 中的生命周期钩子，可以更灵活地管理组件的生命周期。 "),_("code",[v._v("Mixins")]),v._v(" 依然使用 "),_("code",[v._v("Vue2")]),v._v(" 的生命周期钩子。")])]),v._v(" "),_("p",[_("code",[v._v("mixins")]),v._v(" 的优缺点")]),v._v(" "),_("p",[v._v("优点：组件中相同代码逻辑复用；")]),v._v(" "),_("p",[v._v("缺点：")]),v._v(" "),_("ol",[_("li",[v._v("变量来源不明确\n变量来源不明确（隐式传入），不利于阅读，使代码变得难以维护。")]),v._v(" "),_("li",[v._v("命名冲突\n多个 "),_("code",[v._v("mixins")]),v._v(" 的生命周期会融合到一起运行，但是同名属性、同名方法无法融合，可能会导致冲突。")]),v._v(" "),_("li",[v._v("滥用会造成维护问题\n"),_("code",[v._v("mixins")]),v._v(" 和组件可能出现多对多的关系，复杂度较高（即一个组件可以引用多个 "),_("code",[v._v("mixins")]),v._v(" ，一个 "),_("code",[v._v("mixins")]),v._v(" 也可以被多个组件引用）。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);